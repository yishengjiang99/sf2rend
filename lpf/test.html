<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Mocha</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/8.3.2/mocha.min.js"
		integrity="sha512-TfAL33PtGUxii1awTCbr3qbzQT5fYi7ItCGUfzWlnMJ4cK5BA8JNY4gJzEs+tQVbyElVbtcI2Jlaf9EFVMvyeg=="
		crossorigin="anonymous"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/8.3.2/mocha.min.css"
		crossorigin="anonymous" />
	<script src="https://cdnjs.cloudflare.com/ajax/libs/chai/4.3.4/chai.min.js" crossorigin="anonymous"></script>
</head>
<body>
	<div id="mocha">
		<canvas></canvas> <button>play</button> <canvas></canvas>
	</div><input type='range' max=10000 />
	<script type="module">
		mocha.setup("bdd");
		import {LPFWorkletNode} from "./lpf-node.js"; //("lpf-node.js").LPFWorkletNode;
		describe("biquad.c in webworker ", () => {
			const worker = new Worker("worker.js", {type: "module"});
			const srb = new SharedArrayBuffer(128 * Float32Array.BYTES_PER_ELEMENT + 16);
			const flinput = new Float32Array(srb, 0, 128);
			const beep = new Int32Array(srb, 128 * 4, 1);
			it("instantiates via post message", (done) => {

				worker.postMessage({
					options: {
						sampleRate: 48000,
						FilterQ: 1,
						FilterFC: 8321,
					},
					srb
				});
				worker.onmessage = ({data}) => {
					console.log(data);
					chai.expect(data.x1).eq(0)
					chai.expect(data.a1).exists
					chai.expect(data.a1).exists

					done();
				}

			}).timeout(11111);

			it("it performs lpf on valeus stored in srb", async () => {

				let hr1, hr2, result, ts = [];
				for (let i = 0;i < 100;i++) {

					flinput.fill(0);
					flinput[1] = 1;
					flinput[~~(Math.random() * 128)] = 1;
					flinput[11] = 1;
					hr1 = performance.now();
					Atomics.store(beep, 0, 1);

					Atomics.notify(beep, 0, 1);
					const result = Atomics.waitAsync(beep, 0, 1);
					if (result.value instanceof Promise) {
						result.value.then(() => {
							hr2 = performance.now();
							ts.push(hr2 - hr1);
						});
					} else if (result.value == "not-equal") {
						hr2 = performance.now();
						ts.push(hr2 - hr1);
					}



				}
				console.log(ts)

			});


		});
		describe('worklet node', () => {

			it('better work', async () => {
				window.onkeydown = async () => {
					const ctx = new AudioContext();
					const anal1 = new AnalyserNode(ctx, {fftSize: 32}), anal2 =
						new AnalyserNode(ctx, {fftSize: 32}), fl1 = new Float32Array(32), fl2 = new Float32Array(32);
					await LPFWorkletNode.init(ctx);
					const lpfs = new LPFWorkletNode(ctx, {FilterFC: 6900, FilterQ: 2});
					const sq = new OscillatorNode(ctx, {type: "square", frequency: 220});

					sq.connect(lpfs).connect(anal1).connect(ctx.destination);
				//	sq.connect(anal2).connect(ctx.destination);
					sq.connect(ctx.destination);
					sq.start();

					done();
				}
			}).timeout(12312321)
		});

		mocha.run();
		window.onkeydown = async () => {
			const ctx = new AudioContext();
			const anal1 = new AnalyserNode(ctx, {fftSize: 32}), anal2 =
				new AnalyserNode(ctx, {fftSize: 32}), fl1 = new Float32Array(32), fl2 = new Float32Array(32);
			await LPFWorkletNode.init(ctx);
			const lpfs = new LPFWorkletNode(ctx, {FilterFC: 11 * 2, FilterQ: -2});
			const sq = new OscillatorNode(ctx, {type: "square", frequency: 440});

			sq.connect(lpfs).connect(anal1).connect(ctx.destination);
			//		sq.connect(anal2).connect(ctx.destination);
			// sq.connect(ctx.destination);
			sq.start();

		}

	</script>
</body>
</html>
